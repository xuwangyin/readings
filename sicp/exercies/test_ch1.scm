;;
;;; Exercise 1.5
;; (define (p) (p))

;; (define (test x y)
;;   (if (= x 0)
;;       0
;;       y))

;; Then he evaluates the expression

;; (test 0 (p))
;;; applicative-order evaluation
(test 0 (p))
(test 0 (p))
(test 0 (p))

;;;  normal-order evaluation

(test 0 (p))
(if (= 0 0)
    0
    (p))
0

(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))
      )
  )

(factorial 4)
(factorial 1)

;;; Exercise 1.9.
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
(define (fib n)
  (fib-iter 0 1 n))

(define (fib-iter a b count)
  (if (= count 0)
      a
      (fib-iter b (+ a b) (- count 1))
      )
  )

;; Exercise 1.11.  A function f is defined by the rule that
;; f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n -
;; 3) if n> 3. Write a procedure that computes f by means of
;; a recursive process. Write a procedure that computes f by
;; means of an iterative process.
;;; recursive version
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1)) (* (f (- n 2)) 2) (* 3 (f (- n 3))))))
(f 10)
;;; iterative version
(define (f2 n)
  (f-iter 0 1 2 n))
(define (f-iter a b c count)
  (if (= count 2)
      c
      (f-iter b c (+ (* a 3) (* b 2) c) (- count 1))))

(f2 10)


;;;
;;;
;;; Exercise 1.12.
;; (define (pascal-triangle row col)
;;   (if (or (= col row) (= col 1))
;;       1
;;       (+ (pascal-triangle (- row 1) (- col 1))
;;          (pascal-triangle (- row 1) col))))

(define (pascal-triangle row col)
  (cond ((> col row) 0)
        ((< col 0) 0)
        ((= col 1) 1)
        (else (+ (pascal-triangle (- row 1) (- col 1))
                 (pascal-triangle (- row 1) col)))))

(pascal-triangle 1 1)
(pascal-triangle 2 1)
(pascal-triangle 2 1)
(pascal-triangle 3 1)
(pascal-triangle 3 2)
(pascal-triangle 3 3)
(pascal-triangle 4 1)
(pascal-triangle 4 2)
(pascal-triangle 5 3)
(pascal-triangle 0 0)

;;; Exercise 1.14.  Draw the tree illustrating the process
;;; generated by the count-change procedure of section 1.2.2
;;; in making change for 11 cents. What are the orders of
;;; growth of the space and number of steps used by this
;;; process as the amount to be changed increases?
(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) _25)
        ))
(10 5 1)
(cc 11 3)
(+ (cc 11 2) (cc 1 3))
(+ (+ (cc 11 1) (cc 9 2)) (+ (cc 1 2) (cc -9 3)))
(+ (+ (+ (cc 11 0) (cc 8 1)) (+ (cc 9 1) (cc 4 2))))

;;;
;;;
;;; 1.2.4 Exponentation
;;; recursive version
(define (expt b n)
  (if (= n 1)
      b
      (* b (expt b (- n 1)))))

;;; iterative version
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b count product)
  (if (= count 0)
      product
      (expt-iter b (- count 1) (* product b))
      ))
(expt 2 10)

(define (even? x)
  (= (remainder x 2) 0))
(define (fast-expt b n)
  (if (= n 0)
      1
      (if (even? n)
          (square (fast-expt b (/ n 2)))
          (* b (square (fast-expt b (/ (- n 1) 2)))))))

(fast-expt 2 10)
(fast-expt 3 3)

;;;
;;;
;;; Exercise 1.16

(define (fast-expt b n)
  (fast-expt-iter 1 b n))

(define (fast-expt-iter a b n)
  (define (square x)
  (* x x))
  (define (even? x)
  (= (remainder x 2) 0))
  (if (= n 0)
      a
      (if (even? n)
          (fast-expt-iter a (square b) (/ n 2))
          (fast-expt-iter (* a b) b (- n 1)))))
(fast-expt 2 10)
(fast-expt 3 2)
(fast-expt 2 1)
(fast-expt 2 0)

;;;
;;;
;;; Exercise 1.20
;;; normal order
(gcd a b)
(gcd 206 40)
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))
(if (= 40 0)
    206
    (if (= (remainder 206 40) 0)
        40
        (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))))

(if (= 40 0)
    206
    (if (= (remainder 206 40) 0)
        40
        (if (= (remainder 40 (remainder 206 40)))
            (remainder 206 40)
            (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= 40 0)
    206
    (if (= (remainder 206 40) 0)
        40
        (if (= (remainder 40 (remainder 206 40)))
            (remainder 206 40)
            (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
                (remainder 40 (remainder 206 40))
                (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))))

(if (= 40 0)
    206
    (if (= (remainder 206 40) 0)
        40
        (if (= (remainder 40 (remainder 206 40)))
            (remainder 206 40)
            (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
                (remainder 40 (remainder 206 40))
                (if (= (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) 0)
                    ((remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
                    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))))))


;;; applicative order
(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6)
(gcd 6 (remainder 40 6))
(gcd 6 4)
(gcd 4 (remainder 6 4))
(gcd 4 2)
(gcd 2 (remainder 4 2))
(gcd 2 0)
2


;;;
;;;
;;; 1.2.6 Example: Testing for Primality
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides a b)
  (= (remainder b a) 0))
;;; exercise 1.21
(smallest-divisor 1999)
(smallest-divisor 199)
(smallest-divisor 19999)

;;; exercise 1.22
(define (even? x)
  (= (remainder x 2) 0))
;;; test
(even? 3)
(even? 2)
;;;
;; (define (expmod base exp m)
;;   (if (= exp 0)
;;       1
;;       (if (even? exp)
;;           (remainder (square (expmod base (/ exp 2) m)) m)
;;           (remainder (* base (expmod base (/ (- exp 1) 2) m)) m))  )
;;   )
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
;;; test
(expmod 2 10 3)
(expmod 2 10 2)
;;;Fermat's Little Theorem: If n is a prime number and a is
;;;any positive integer less than n, then a raised to the
;;;nth power is congruent to a modulo n.
;;;a^n % n = a
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1))))
  )
;;; test
(fermat-test 1999)
(fermat-test 7)
(fermat-test 4)
;;;
(define (prime? n)
  (define (fast-prime? n times)
    (cond ((= times 0) true)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else false)))
  (fast-prime? n 1)
  )

(define (smallest-divisor n)
  (define (divides n divisor)
    (= (remainder n divisor) 0))
  (define (next divisor)
    (if (= divisor 2)
        3
        (+ divisor 2)))
  (define (smallest-divisor-iter n divisor)
    (cond ((> (square divisor) n) n)
          ((divides n divisor) divisor)
          (else (smallest-divisor-iter n (next divisor)))))
  (smallest-divisor-iter n 2)
  )
(smallest-divisor 4)
(define (prime? n)
  (if (= n 1)                           ; 1 is not a prime number
      false
      (= n (smallest-divisor n))))
;;; test
(prime? 1999)
(prime? 4)
(prime? 1)
(prime? 2)
;;;

(define (report-time elapsed-time)
  (display " *** ")
  (display elapsed-time))
;;; test
(report-time 10)
;;;
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-time (- (runtime) start-time)))
  )
(start-prime-test 19999999 (runtime))
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime))
  )
(timed-prime-test 19999)
(timed-prime-test 3)
(define (search-for-primes begin end)
  (define (search-iter begin end)
    (if (>= end begin) (timed-prime-test begin))
    (if (>= end begin) (search-iter (+ begin 2) end)))
  (search-iter (if (even? begin) (+ begin 1) begin)
               end))
(search-for-primes 1000 1019)
(search-for-primes 10000 10037)
(search-for-primes 100000 100043)
(search-for-primes 1000000 1000037)
;;;
;;;
;;; Exercise 1.29.
(define (even? k)
  (= (remainder k 2) 0))
(define (increase k)
  (+ k 1))
(define (coef k n)
  (cond ((or (= k 0) (= k n)) 1)
        (else (if (even? k)
                  2
                  4))))
(define (simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-product k)
    (* (coef k n) (f (+ a (* k h)))))
  (* (sum simpson-product 0 increase n) (/ h 3)))
(define (cube x)
  (* x x x))
(simpson cube 0 1 10)
;;; Exercise 1.30.  The sum procedure above generates a
;;; linear recursion. The procedure can be rewritten so that
;;; the sum is performed iteratively.
;;; recursive version
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
;;; iterative version
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter (next a) (term a)))
(sum (lambda (x) x) 1 (lambda (x) (+ x 1)) 10)

;;;
;;; recursive version
(define (product term a next b)
  (if (> a b)
      1
      (* (term a) (product term (next a) next b))))
;;; iterative version
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter (next a) (term a)))
;;;approximations to pi
(* (product (lambda (x) (/ (* (- x 1) (+ x 1)) (square x))) 3 (lambda (x) (+ x 2)) 20) 4)
;;;
;;;Exercise 1.32.  a. Show that sum and product (exercise 1.31) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function:

;;; (accumulate combiner null-value term a next b)
;;; recursive version
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a) (accumulate combiner null-value term (next a) next b))))
;;; iterative version
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter (next a) (term a)))

(accumulate (lambda (x y) (+ x y)) 0 (lambda (x) x) 1 (lambda (x) (+ 1 x)) 10)
(accumulate (lambda (x y) (* x y)) 1 (lambda (x) x) 1 (lambda (x) (+ 1 x)) 10)
;;; Exercise 1.33.
(define (filtered-accumulate combiner null-value term a next b predicate)
  (cond ((> a b) null-value)
        ((predicate a) (combiner (term a) (filtered-accumulate combiner null-value term (next a) next b predicate)))
        (else (combiner null-value (filtered-accumulate combiner null-value term (next a) next b predicate)))))
(filtered-accumulate (lambda (x y) (+ x y)) 0 (lambda (x) (square x)) 1 (lambda (x) (+ x 1)) 997 prime?)

(define (display-primes a b)
  (if (and (<= a b) (prime? a))
      (display a))
  (if (<= a b) (display-primes (+ a 1) b)))
(display-primes 1 10)

(define (smallest-divisor n)
  (define (divides n divisor)
    (= (remainder n divisor) 0))
  (define (next divisor)
    (if (= divisor 2)
        3
        (+ divisor 2)))
  (define (smallest-divisor-iter n divisor)
    (cond ((> (square divisor) n) n)
          ((divides n divisor) divisor)
          (else (smallest-divisor-iter n (next divisor)))))
  (smallest-divisor-iter n 2)
  )
(define (prime? n)
  (if (= n 1)                           ; 1 is not a prime
      false
      (= n (smallest-divisor n))))

;;; a. the sum of the squares of the prime numbers in the
;;; interval ato b
(filtered-accumulate (lambda (x y) (+ x y)) 0 (lambda (x) (square x)) 1 (lambda (x) (+ x 1)) 10 prime?)
;;;
;;;
;;;Exercise 1.34.
(define (f g)
  (g 2))

(f f)
evaluate (f 2)
evaluate (2 2)
"2" is not applicable.

;;; Exercise 1.35.

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1)
;;; Exercise 1.
;;; a modified version of fixed-point procedure so that it
;;; prints the sequence of approximations it generates.
(define (fixed-point f first-guess)
  (define tolerance 0.00000001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
(fixed-point cos 1.0)
(define (gcd a b)
  (newline)
  (display a)
  (display " ")
  (display b)
  (if (= b 0)
      a
      (gcd b (remainder a b)))
  )
(gcd 28 493)
(define (fact-iter product counter max-count)
  (newline)
  (display product)
  (display " " )
  (display counter)
  (display " ")
  (display max-count)
  (display " ")
  (if (> counter max-count)
      product
      (fact-iter (* product counter) (+ counter 1) max-count)))
(define (factorial n)
  (fact-iter 1 1 n))
(factorial 6)
;;; a modified version of fixed-point procedure so that it
;;; prints the sequence of approximations it generates and
;;; using average damping.(x^x = 1000)
;;; instead of choose between x and log(1000)/log(x), we
;;; choose between x and 1/2*(log(1000)/log(x)), this was
;;; called "average damping". note the equation x =
;;; 1/2*(log(1000)/log(x)) yields equation x =
;;; log(1000)/log(x)
(define (average a b)
  (/ (+ a b) 2.0))
(define (fixed-point f first-guess)
  (define (close-enough? guess)
    (define tolerance 0.00000001)
    (< (abs (- guess (f guess))) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (average guess (f guess))))
      (if (close-enough? guess)
          guess
          (try next))))
  (try first-guess))
(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)

;;;
;;;Exercise 1.37.
;;; recursive version
(define (cont-frac n d k)
  (define (cont-frac-recursive n d k counter)
    (if (> counter k)
        0.0
        (/ (n counter) (+ (d counter) (cont-frac-recursive n d k (+ counter 1))))))
  (cont-frac-recursive n d k 1))

(/ 1 (cont-frac (lambda (x) 1.0) (lambda (x) 1.0) 10000))
;;; iterative version
(define (cont-frac n d k)
  (define (cont-frac-iterative n d k result)
    (if (= k 0)
        result
        (cont-frac-iterative n d (- k 1) (/ (n k) (+ (d k) result)))))
  (cont-frac-iterative n d k 0.0))
(/ 1 (cont-frac (lambda (x) 1.0) (lambda (x) 1.0) 10000))

;;;Exercise 1.38.
(define (cont-frac n d k)
  (define (cont-frac-iterative n d k result)
    (if (= k 0)
        result
        (cont-frac-iterative n d (- k 1) (/ (n k) (+ (d k) result)))))
  (cont-frac-iterative n d k 0.0))
(define (d k)
  (if (= (remainder k 3) 2)
      (* 2 (+ 1 (floor (/ k 3))))
      1))
(+ 2 (cont-frac (lambda (x) 1) d 50))

(define (average a b)
  (/ (+ a b) 2))
(define (sqrt-iter guess x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.000001))
  (define (improve guess)
    (average guess (/ x guess)))
  (if (good-enough? guess)
      guess
      (sqrt-iter (improve guess) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(sqrt 2)

;;; Exercise 1.41
(define (fixed-point f guess)
  (define next-guess
    (f guess))
  (define (close-enough? guess)
    (define tolerance 0.00000001)
    (< (abs (- guess next-guess)) tolerance))
  (if (close-enough? guess)
      guess
      (fixed-point f next-guess)))

(define (square x)
  (* x x))
(define (cubic a b c)
  (lambda (x) (+ c (* b x) (* a (square x)) (* x x x))))

(define (deriv g)
  (define dx 0.00000001)
  (lambda (x)(/ (- (g (+ x dx)) (g x)) dx)))
(define (newtons-method g guess)
  (define (newtons-transform g)
    (lambda (x) (- x (/ (g x) ((deriv g) x)))))
  (fixed-point (newtons-transform g) guess))

(newtons-method (cubic 1 2 3) 1.0)
;;;
;;; Exercise 1.42.
(define (compose f g)
  (lambda (x) (f (g x))))
(define (inc x)
  (+ x 1))
((compose square inc) 6)
;;; Exercise 1.43.
(define (repeated f n)
  (if (= n 1)
      (lambda (x) (f x))
      (lambda (x) (f ((repeated f (- n 1)) x)))))
((repeated square 2) 5)
;;; Exercise 1.44.
(define (average x y z)
  (/ (+ x y z) 3))
(define (smooth f)
  (define dx 0.001)
  (lambda (x) (average (f (- x dx)) (f x) (f (+ x dx)))))
(smooth (cubic 1 2 3))
(newtons-method (smooth (cubic 1 2 3)) 1.0)
;;; generate n-fold smoothed function
(define (n-fold-smoothed f)
  (lambda (x) ((repeated (smooth f) n) x)))
;;;
;;; Exercise 1.45.
;;; fourth roots


(define (average-damp f)
  (define (average x y)
    (/ (+ x y) 2))
  (lambda (x) (average x (f x))))

(define (nth-average-damp f n)
  (define (repeated f n)
  (if (= n 1)
      (lambda (x) (f x))
      (lambda (x) (f ((repeated f (- n 1)) x)))))
  (lambda (x) ((repeated (average-damp f) n) x)))

(define (root x n)
  (fixed-point (nth-average-damp (lambda (y) (/ x (pow y (- n 1)))) 5) 2.0))
(root 2 6)
(root 2 5) 
(root 2 4)
(root 2 3)
(root 2 2)
(root 2 1)
(define (test x nth)
  (define tolerance 0.01)
  (< (abs (- x (pow (root x nth) nth))) tolerance))
(test 2 3)
(abs (- 2 (pow (root 2 4) 4)))

(define (pow x n)
  (define (square x)
    (* x x))
  (define (even? x)
    (= (remainder x 2) 0))
  (define (pow-iter a n b)
    (if (= n 0)
        a
        (if (even? n)
            (pow-iter a (/ n 2) (square b))
            (pow-iter (* a b) (- n 1) b))))
  (pow-iter 1 n x))

(define (fixed-point f guess)
  (define next-guess
    (f guess))
  (define (good-enough? guess)
    (define tolerance 0.00000001)
    (< (abs (- guess next-guess)) tolerance))
  (if (good-enough? guess)
      guess
      (fixed-point f next-guess))
  )
(fixed-point (average-damp cos) 1.0)
(fixed-point (nth-average-damp cos 10) 1.0)
;;; Exercise 1.46. 
(define (iterative-improve good-enough? improve)
  (lambda (x)
    (if (good-enough? x)
        x
        ((iterative-improve good-enough? improve) (improve x)))))

(define (fixed-point f first-guess)
  (define (average x y)
    (/ (+ x y) 2))
  (define (improve x)
    (average x (f x)))
  (define (good-enough? x)
    (< (abs (- x (f x))) 0.00001))
  ((iterative-improve good-enough? improve) first-guess)
  )

(fixed-point cos 1.0)
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
